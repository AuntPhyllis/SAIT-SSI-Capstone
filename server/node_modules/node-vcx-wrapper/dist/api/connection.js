"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ffi = require("ffi");
const ref = require("ref");
const errors_1 = require("../errors");
const rustlib_1 = require("../rustlib");
const ffi_helpers_1 = require("../utils/ffi-helpers");
const common_1 = require("./common");
const vcx_base_with_state_1 = require("./vcx-base-with-state");
function voidPtrToUint8Array(origPtr, length) {
    /**
     * Read the contents of the pointer and copy it into a new Buffer
     */
    const ptrType = ref.refType('uint8 *');
    const pointerBuf = ref.alloc(ptrType, origPtr);
    const newPtr = ref.readPointer(pointerBuf, 0, length);
    const newBuffer = Buffer.from(newPtr);
    return newBuffer;
}
exports.voidPtrToUint8Array = voidPtrToUint8Array;
/**
 * @class Class representing a Connection
 */
class Connection extends vcx_base_with_state_1.VCXBaseWithState {
    constructor() {
        super(...arguments);
        this._releaseFn = rustlib_1.rustAPI().vcx_connection_release;
        this._updateStFn = rustlib_1.rustAPI().vcx_connection_update_state;
        this._updateStWithMessageFn = rustlib_1.rustAPI().vcx_connection_update_state_with_message;
        this._getStFn = rustlib_1.rustAPI().vcx_connection_get_state;
        this._serializeFn = rustlib_1.rustAPI().vcx_connection_serialize;
        this._deserializeFn = rustlib_1.rustAPI().vcx_connection_deserialize;
        this._inviteDetailFn = rustlib_1.rustAPI().vcx_connection_invite_details;
    }
    /**
     * Create a connection object, represents a single endpoint and can be used for sending and receiving
     * credentials and proofs
     *
     * Example:
     * ```
     * source_id = 'foobar123'
     * connection = await Connection.create(source_id)
     * ```
     */
    static create({ id }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const connection = new Connection(id);
                const commandHandle = 0;
                yield connection._create((cb) => rustlib_1.rustAPI().vcx_connection_create(commandHandle, id, cb));
                return connection;
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Create a connection object with a provided invite, represents a single endpoint and can be used for
     * sending and receiving credentials and proofs.
     * Invite details are provided by the entity offering a connection and generally pulled from a provided QRCode.
     *
     * Example:
     * ```
     * sourceId = 'foobar123'
     * connection_handle = await Connection.createWithInvite({sourceId, inviteDetails})
     * ```
     */
    static createWithInvite({ id, invite }) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = new Connection(id);
            const commandHandle = 0;
            try {
                yield connection._create((cb) => rustlib_1.rustAPI().vcx_connection_create_with_invite(commandHandle, id, invite, cb));
                return connection;
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Create the object from a previously serialized object.
     * Example:
     * data = await connection1.serialize()
     * connection2 = await Connection.deserialize(data)
     */
    static deserialize(connectionData) {
        const _super = Object.create(null, {
            _deserialize: { get: () => super._deserialize }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const connection = yield _super._deserialize.call(this, Connection, connectionData);
            return connection;
        });
    }
    /**
     *
     * Updates the state of the connection from the given message.
     *
     * Example:
     * ```
     * await object.updateStateWithMessage(message)
     * ```
     * @returns {Promise<void>}
     */
    updateStateWithMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const commandHandle = 0;
                yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_update_state_with_message(commandHandle, this.handle, message, cb);
                    if (rc) {
                        resolve(common_1.StateType.None);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32', 'uint32'], (handle, err, state) => {
                    if (err) {
                        reject(err);
                    }
                    resolve(state);
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Delete the object from the agency and release any memory associated with it
     *
     * Example:
     * ```
     * def connection = await Connection.create(source_id)
     * await connection.delete()
     * ```
     */
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_delete_connection(0, this.handle, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32'], (xcommandHandle, err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve();
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Creates a connection between enterprise and end user.
     *
     * Example:
     * ```
     * connection = await Connection.create('foobar123')
     * inviteDetails = await connection.connect(
     *     {data: '{"connection_type":"SMS","phone":"5555555555"}',"use_public_did":true})
     * ```
     * @returns {Promise<string}
     */
    connect(connectionData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_connect(0, this.handle, connectionData.data, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32', 'string'], (xHandle, err, details) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (!details) {
                        reject(`Connection ${this.sourceId} connect returned empty string`);
                        return;
                    }
                    resolve(details);
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Sends a message to the connection.
     *
     * Example:
     * ```
     * msg_id = await connection.send_message(
     *     {msg:"are you there?",type:"question","title":"Sending you a question"})
     * ```
     * @returns {Promise<string}
     */
    sendMessage(msgData) {
        return __awaiter(this, void 0, void 0, function* () {
            const sendMsgOptions = {
                msg_title: msgData.title,
                msg_type: msgData.type,
                ref_msg_id: msgData.refMsgId
            };
            try {
                return yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_send_message(0, this.handle, msgData.msg, JSON.stringify(sendMsgOptions), cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32', 'string'], (xHandle, err, details) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (!details) {
                        reject(`Connection ${this.sourceId} connect returned empty string`);
                        return;
                    }
                    resolve(details);
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Sign data using pairwise key.
     *
     * Example:
     * ```
     * signature = await connection.signData(bufferOfBits)
     * ```
     * @returns {Promise<string}
     */
    signData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_sign_data(0, this.handle, ref.address(data), data.length, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32', 'pointer', 'uint32'], (xHandle, err, details, length) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (!details) {
                        reject(`Connection ${this.sourceId}  returned empty buffer`);
                        return;
                    }
                    const newBuffer = voidPtrToUint8Array(details, length);
                    resolve(newBuffer);
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Verify the signature of the data using pairwise key.
     *
     * Example:
     * ```
     * valid = await connection.verifySignature({data: bufferOfBits, signature: signatureBits})
     * ```
     * @returns {Promise<string}
     */
    verifySignature(signatureData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_verify_signature(0, this.handle, ref.address(signatureData.data), signatureData.data.length, ref.address(signatureData.signature), signatureData.signature.length, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32', 'bool'], (xHandle, err, valid) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(valid);
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Gets the details of the invitation that was returned from the Agent Service.
     *
     * Example:
     * ```
     * phoneNumber = '8019119191'
     * connection = await Connection.create('foobar123')
     * inviteDetails = await connection.connect({phone: phoneNumber})
     * inivteDetailsAgain = await connection.inviteDetails()
     * ```
     */
    inviteDetails(abbr = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = this._inviteDetailFn(0, this.handle, abbr, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32', 'string'], (handle, err, details) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (!details) {
                        reject('no details returned');
                        return;
                    }
                    resolve(details);
                }));
                return data;
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Redirects to an existing connection if one already present.
     *
     * Example:
     * ```
     * const oldConnectionToAcme = searchConnectionsByPublicDID({
     *  public_did: inviteDetails.publicDID
     * })
     * const redirectConnectionToAcme = await Connection.createWithInvite({
     *  id: 'faber-redirect',
     *  invite: JSON.stringify(inviteDetails)
     * })
     * await redirectConnectionToAcme.redirect({
     *  redirectToConnection: oldConnectionToAcme
     * })
     * ```
     */
    connectionRedirect(existingConnection) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_redirect(0, this.handle, existingConnection.handle, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback('void', ['uint32', 'uint32'], (xcommandHandle, err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve();
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
    /**
     * Gets the redirection details if the connection already exists.
     *
     * Example:
     * ```
     * await connectionToAlice.updateState()
     * connectionState = await connectionToAlice.getState()
     *
     * if (connectionState == StateType.Redirected) {
     * redirectDetails = await connectionToAlice.getRedirectDetails()
     * serializedOldConnection = searchConnectionsByTheirDid({
     *   theirDid: redirectDetails.theirDID
     * })
     * oldConnection = await Connection.deserialize({
     *   connectionData: serializedOldConnection
     * })
     *}
     * ```
     */
    getRedirectDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield ffi_helpers_1.createFFICallbackPromise((resolve, reject, cb) => {
                    const rc = rustlib_1.rustAPI().vcx_connection_get_redirect_details(0, this.handle, cb);
                    if (rc) {
                        reject(rc);
                    }
                }, (resolve, reject) => ffi.Callback("void", ["uint32", "uint32", "string"], (xHandle, err, details) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (!details) {
                        reject(`no redirect details returned`);
                        return;
                    }
                    resolve(details);
                }));
            }
            catch (err) {
                throw new errors_1.VCXInternalError(err);
            }
        });
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map